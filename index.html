<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Professional CCTV Design Simulator</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom Styles for better aesthetics and clarity */
        :root {
            --color-id: #dc2626; /* Red for Identification */
            --color-rec: #fb923c; /* Orange for Recognition */
            --color-det: #facc15; /* Yellow for Detection */
            --color-mon: #3b82f6; /* Blue for Monitoring/General */
            --canvas-bg: #e5e7eb; /* Light gray background for contrast */
        }
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6;
            min-height: 100vh;
        }
        /* Style the canvas to ensure it's clearly visible */
        #cctvCanvas {
            border: 1px solid #d1d5db;
            background-color: var(--canvas-bg);
            border-radius: 0.75rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            touch-action: none; /* Prevent unwanted touch behavior on canvas */
        }
        /* Custom styled range input */
        input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 8px;
            background: #d1ddff;
            outline: none;
            opacity: 0.7;
            -webkit-transition: .2s;
            transition: opacity .2s;
            border-radius: 4px;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #4f46e5;
            cursor: pointer;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
        }
    </style>
</head>
<body class="p-4 md:p-8">

<div class="max-w-7xl mx-auto">
    <!-- Header -->
    <header class="text-center mb-8">
        <h1 class="text-3xl md:text-4xl font-extrabold text-indigo-700">CCTV Design & Coverage Simulator</h1>
        <p class="text-gray-500 mt-1">Visualize DORI zones and calculate system capacity in real-time.</p>
    </header>

    <div class="grid grid-cols-1 lg:grid-cols-3 gap-8">

        <!-- Input Panel (Column 1) -->
        <div class="lg:col-span-1 bg-white p-6 rounded-xl shadow-lg h-full">
            <h2 class="text-2xl font-semibold mb-6 text-gray-800 border-b pb-2">Camera Parameters</h2>

            <form id="cameraConfig" class="space-y-4">
                <!-- Resolution -->
                <div>
                    <label for="resolution" class="block text-sm font-medium text-gray-700">Horizontal Resolution (Pixels)</label>
                    <select id="resolution" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm p-2 bg-gray-50 focus:border-indigo-500 focus:ring-indigo-500">
                        <option value="1920">1080p (1920 px)</option>
                        <option value="2560" selected>2K/4MP (2560 px)</option>
                        <option value="3840">4K/8MP (3840 px)</option>
                        <option value="5120">5K/12MP (5120 px)</option>
                    </select>
                </div>

                <!-- Sensor Size -->
                <div>
                    <label for="sensorSize" class="block text-sm font-medium text-gray-700">Sensor Width (mm) - 1/2.8" is ~5.1mm</label>
                    <input type="number" id="sensorSize" value="5.1" step="0.1" min="1" max="10" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm p-2 focus:border-indigo-500 focus:ring-indigo-500">
                </div>

                <!-- Horizontal Field of View (HFOV) -->
                <div>
                    <label for="hfov" class="block text-sm font-medium text-gray-700">Horizontal FoV (Degrees) <span id="hfovValue" class="font-bold text-indigo-600">60</span>&deg;</label>
                    <input type="range" id="hfov" min="15" max="120" value="60" step="1" class="mt-2">
                </div>

                <!-- Mounting Height -->
                <div>
                    <label for="mountingHeight" class="block text-sm font-medium text-gray-700">Mounting Height (Meters)</label>
                    <input type="number" id="mountingHeight" value="3.5" step="0.1" min="1" max="10" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm p-2 focus:border-indigo-500 focus:ring-indigo-500">
                </div>
            </form>
        </div>

        <!-- Simulation & Controls (Column 2) -->
        <div class="lg:col-span-2 bg-white p-6 rounded-xl shadow-lg h-full flex flex-col">
            <h2 class="text-2xl font-semibold mb-4 text-gray-800 border-b pb-2">2D Coverage Simulation</h2>
            <div class="flex-grow relative aspect-[3/2] min-h-[300px]">
                <!-- Canvas for 2D Simulation -->
                <canvas id="cctvCanvas" class="w-full h-full"></canvas>
            </div>
            
            <div class="mt-6">
                <h3 class="text-lg font-semibold mb-2 text-gray-700">Legend (DORI Zones)</h3>
                <div class="flex flex-wrap gap-4 text-sm">
                    <span class="flex items-center"><div class="w-3 h-3 rounded-full mr-2" style="background-color: var(--color-id);"></div>Identification (&gt;250 PPM)</span>
                    <span class="flex items-center"><div class="w-3 h-3 rounded-full mr-2" style="background-color: var(--color-rec);"></div>Recognition (125-250 PPM)</span>
                    <span class="flex items-center"><div class="w-3 h-3 rounded-full mr-2" style="background-color: var(--color-det);"></div>Detection (62-125 PPM)</span>
                    <span class="flex items-center"><div class="w-3 h-3 rounded-full mr-2" style="background-color: var(--color-mon);"></div>Monitoring (&lt;62 PPM)</span>
                </div>
            </div>
        </div>
    </div>

    <!-- Output Panel (Below simulation) -->
    <div class="mt-8 bg-white p-6 rounded-xl shadow-lg grid grid-cols-1 md:grid-cols-3 gap-6">
        <h2 class="text-2xl md:col-span-3 font-semibold text-gray-800 border-b pb-2 mb-4">Calculated Results</h2>

        <!-- Focal Length -->
        <div class="p-4 bg-indigo-50 rounded-lg">
            <p class="text-sm font-medium text-indigo-700">Required Focal Length</p>
            <p id="focalLengthOutput" class="text-2xl font-bold text-indigo-900 mt-1">-- mm</p>
        </div>

        <!-- Pixel Density (PPM) at 10m -->
        <div class="p-4 bg-green-50 rounded-lg">
            <p class="text-sm font-medium text-green-700">PPM at 10 Meters (Target)</p>
            <p id="ppm10mOutput" class="text-2xl font-bold text-green-900 mt-1">-- PPM</p>
        </div>

        <!-- Bandwidth & Storage -->
        <div class="p-4 bg-purple-50 rounded-lg md:col-span-1">
            <p class="text-sm font-medium text-purple-700">Est. Bandwidth / Storage (H.264, 15 FPS)</p>
            <p id="networkOutput" class="text-lg font-bold text-purple-900 mt-1">-- Mbps / -- GB/Day</p>
        </div>
    </div>
</div>

<script>
document.addEventListener('DOMContentLoaded', () => {
    const canvas = document.getElementById('cctvCanvas');
    const ctx = canvas.getContext('2d');
    const configForm = document.getElementById('cameraConfig');
    const hfovRange = document.getElementById('hfov');
    const hfovValueSpan = document.getElementById('hfovValue');
    const focalLengthOutput = document.getElementById('focalLengthOutput');
    const ppm10mOutput = document.getElementById('ppm10mOutput');
    const networkOutput = document.getElementById('networkOutput');

    // DORI standards in Pixels Per Meter (PPM)
    const DORI_PPM = {
        ID: 250, // Identification
        REC: 125, // Recognition
        DET: 62,  // Detection
        MON: 31   // Monitoring (This will be the minimum draw limit)
    };

    const DORI_COLORS = {
        ID: 'rgba(220, 38, 38, 0.5)',    // Red
        REC: 'rgba(251, 146, 60, 0.5)',  // Orange
        DET: 'rgba(250, 204, 21, 0.5)',  // Yellow
        MON: 'rgba(59, 130, 246, 0.5)'   // Blue
    };

    let cameraState = {
        resolution: 2560, // Horizontal pixels
        sensorSize: 5.1,  // Sensor width in mm (1/2.8")
        hfov: 60,         // Horizontal Field of View in degrees
        mountingHeight: 3.5, // Meters
        maxDistance: 30, // Max distance for drawing the cone in meters
        scale: 1, // Pixels per meter on canvas (calculated dynamically)
        
        // Calculated results
        focalLength: 0,
        ppmAt10m: 0,
        fovWidthAt10m: 0,
        doriDistances: {}
    };

    /**
     * Converts degrees to radians.
     * @param {number} degrees
     * @returns {number} radians
     */
    const toRadians = (degrees) => degrees * (Math.PI / 180);

    /**
     * Calculates the required focal length and FoV width.
     * Updates the cameraState object with new values.
     */
    const calculateCoverage = () => {
        const hfovRad = toRadians(cameraState.hfov);

        // 1. Calculate Focal Length (f in mm)
        // f = sensorWidth / (2 * tan(HFOV/2))
        const focalLength = cameraState.sensorSize / (2 * Math.tan(hfovRad / 2));
        cameraState.focalLength = parseFloat(focalLength.toFixed(2));

        // 2. Calculate FoV Width at a specific distance (10 meters used as reference)
        // W = 2 * D * tan(HFOV/2)
        const refDistance = 10; // meters
        const fovWidthAt10m = 2 * refDistance * Math.tan(hfovRad / 2);
        cameraState.fovWidthAt10m = parseFloat(fovWidthAt10m.toFixed(2));

        // 3. Calculate PPM at reference distance
        // PPM = Resolution / FoV Width (in meters)
        const ppmAt10m = cameraState.resolution / fovWidthAt10m;
        cameraState.ppmAt10m = Math.round(ppmAt10m);

        // 4. Calculate DORI Distances (Distance D for a required PPM)
        // D = (Resolution / PPM_Target) / (2 * tan(HFOV/2))
        const calcDistance = (ppmTarget) => {
            if (ppmTarget === 0) return 0;
            return (cameraState.resolution / ppmTarget) / (2 * Math.tan(hfovRad / 2));
        };

        cameraState.doriDistances = {
            ID: parseFloat(calcDistance(DORI_PPM.ID).toFixed(2)),
            REC: parseFloat(calcDistance(DORI_PPM.REC).toFixed(2)),
            DET: parseFloat(calcDistance(DORI_PPM.DET).toFixed(2)),
            MON: parseFloat(calcDistance(DORI_PPM.MON).toFixed(2))
        };
        
        // Update max distance based on the Monitoring distance + a buffer
        cameraState.maxDistance = Math.max(30, cameraState.doriDistances.MON + 5);
    };
    
    /**
     * Calculates estimated bandwidth and storage requirements.
     * Uses simplified estimates for H.264 at 15 FPS.
     * @returns {{bandwidthMbps: number, storageGBPerDay: number}}
     */
    const calculateNetworkCapacity = () => {
        // Base bitrate assumptions (rough estimate for H.264, 15 FPS, based on resolution and scene complexity)
        // These are estimates and depend heavily on actual codec/scene/quality settings.
        let baseBitrateKbps;
        switch(cameraState.resolution) {
            case 1920: // 1080p
                baseBitrateKbps = 3000; // ~3 Mbps
                break;
            case 2560: // 2K/4MP
                baseBitrateKbps = 6000; // ~6 Mbps
                break;
            case 3840: // 4K/8MP
                baseBitrateKbps = 10000; // ~10 Mbps
                break;
            case 5120: // 5K/12MP
                baseBitrateKbps = 15000; // ~15 Mbps
                break;
            default:
                baseBitrateKbps = 4000;
        }

        // Bandwidth: Convert Kbps to Mbps
        const bandwidthMbps = baseBitrateKbps / 1000;

        // Storage Calculation (GB per day)
        // Storage_MB = (Bitrate_kbps * 3600 seconds/hr * 24 hours/day) / (8 bits/byte * 1024 KB/MB * 1024 MB/GB)
        const totalBitsPerDay = baseBitrateKbps * 1000 * 3600 * 24; // bits/day
        const totalBytesPerDay = totalBitsPerDay / 8; // bytes/day
        const storageGBPerDay = totalBytesPerDay / 1024 / 1024 / 1024; // GB/day

        return {
            bandwidthMbps: parseFloat(bandwidthMbps.toFixed(2)),
            storageGBPerDay: parseFloat(storageGBPerDay.toFixed(2))
        };
    };
    

    /**
     * Draws the 2D simulation on the canvas.
     */
    const drawSimulation = () => {
        // Clear canvas
        canvas.width = canvas.clientWidth;
        canvas.height = canvas.clientHeight;
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Calculate scale: meters per pixel
        const padding = 20; // Padding from canvas edge
        // Determine the scale based on the maximum distance to display
        cameraState.scale = (canvas.height - padding) / cameraState.maxDistance;

        // Origin point (Camera position at the center bottom)
        const originX = canvas.width / 2;
        const originY = canvas.height - 5; // Slightly above the very bottom

        // HFOV in radians
        const hfovRad = toRadians(cameraState.hfov);
        const halfHFovRad = hfovRad / 2;

        // Function to convert distance (meters) to Y coordinate (pixels)
        const distToY = (distance) => originY - (distance * cameraState.scale);

        // Function to calculate FoV half-width (meters) at a given distance (D)
        // W/2 = D * tan(HFOV/2)
        const fovHalfWidth = (distance) => distance * Math.tan(halfHFovRad);

        // Draw DORI zones from furthest (MON) to nearest (ID)
        const zones = [
            { distance: cameraState.doriDistances.MON, color: DORI_COLORS.MON, label: 'MON' },
            { distance: cameraState.doriDistances.DET, color: DORI_COLORS.DET, label: 'DET' },
            { distance: cameraState.doriDistances.REC, color: DORI_COLORS.REC, label: 'REC' },
            { distance: cameraState.doriDistances.ID, color: DORI_COLORS.ID, label: 'ID' }
        ];

        let prevY = originY;
        let prevDistance = 0;

        for (let i = 0; i < zones.length; i++) {
            const zone = zones[i];
            const startDistance = prevDistance;
            const endDistance = zone.distance;

            // Don't draw if the max zone is out of bounds or calculation failed
            if (endDistance <= 0 || endDistance > cameraState.maxDistance + 5) continue;
            
            // Draw a wedge for the segment
            ctx.beginPath();
            ctx.fillStyle = zone.color;
            
            // Start at the camera point (origin)
            ctx.moveTo(originX, originY);
            
            // 1. Arc/line at the start distance (prevDistance) - this makes the cone smooth
            const startX_Left = originX - (fovHalfWidth(startDistance) * cameraState.scale);
            const startX_Right = originX + (fovHalfWidth(startDistance) * cameraState.scale);
            
            // Draw the start line (prev distance line)
            if (i > 0) { // Skip for the very first segment (camera origin)
                ctx.lineTo(startX_Right, distToY(startDistance));
                ctx.lineTo(startX_Left, distToY(startDistance));
            }

            // 2. Arc/line at the end distance (zone.distance)
            const endX_Left = originX - (fovHalfWidth(endDistance) * cameraState.scale);
            const endX_Right = originX + (fovHalfWidth(endDistance) * cameraState.scale);
            
            ctx.lineTo(endX_Right, distToY(endDistance));
            ctx.lineTo(endX_Left, distToY(endDistance));
            
            ctx.closePath();
            ctx.fill();

            // Update for the next iteration
            prevDistance = endDistance;
        }
        
        // Finish the cone up to the max draw distance for monitoring area
        const finalX_Left = originX - (fovHalfWidth(cameraState.maxDistance) * cameraState.scale);
        const finalX_Right = originX + (fovHalfWidth(cameraState.maxDistance) * cameraState.scale);
        
        ctx.beginPath();
        ctx.fillStyle = 'rgba(59, 130, 246, 0.1)'; // Very light blue for max range
        ctx.moveTo(originX, originY);
        ctx.lineTo(finalX_Right, distToY(cameraState.maxDistance));
        ctx.lineTo(finalX_Left, distToY(cameraState.maxDistance));
        ctx.closePath();
        ctx.fill();


        // Draw the Camera Icon
        ctx.beginPath();
        ctx.arc(originX, originY, 5, 0, 2 * Math.PI);
        ctx.fillStyle = '#1e3a8a'; // Dark blue for camera
        ctx.fill();
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.stroke();

        // Draw distance markers (grid)
        ctx.strokeStyle = '#9ca3af';
        ctx.lineWidth = 1;
        ctx.font = '10px Inter';
        ctx.fillStyle = '#1f2937';
        for (let d = 5; d <= cameraState.maxDistance; d += 5) {
            const y = distToY(d);
            
            // Draw horizontal line
            ctx.beginPath();
            ctx.moveTo(originX - 10, y);
            ctx.lineTo(canvas.width, y);
            ctx.setLineDash([5, 5]); // Dashed line
            ctx.stroke();
            ctx.setLineDash([]); // Solid line

            // Label
            ctx.fillText(`${d}m`, originX + 15, y + 3);
        }

        // Add DORI label lines on the right side
        ctx.lineWidth = 2;
        ctx.font = '12px Inter Bold';
        
        // Only draw labels for calculated DORI points
        const sortedDistances = Object.entries(cameraState.doriDistances)
            .sort((a, b) => b[1] - a[1]) // Sort from far to near
            .filter(([key, distance]) => distance > 0 && distance <= cameraState.maxDistance);

        sortedDistances.forEach(([key, distance]) => {
            const y = distToY(distance);
            const xRight = originX + (fovHalfWidth(distance) * cameraState.scale);
            
            // Draw line to the label
            ctx.beginPath();
            ctx.strokeStyle = DORI_COLORS[key].replace('0.5', '1'); // Use solid color for line
            ctx.moveTo(xRight, y);
            ctx.lineTo(xRight + 30, y); // Short horizontal line
            ctx.stroke();

            // Draw label
            let labelText = '';
            let labelColor = DORI_COLORS[key].replace('0.5', '1');
            switch(key) {
                case 'ID': labelText = `ID: ${distance}m`; break;
                case 'REC': labelText = `REC: ${distance}m`; break;
                case 'DET': labelText = `DET: ${distance}m`; break;
                case 'MON': labelText = `MON: ${distance}m`; break;
            }
            ctx.fillStyle = labelColor;
            ctx.fillText(labelText, xRight + 35, y + 4);
        });

    };

    /**
     * Main update function: reads inputs, recalculates, and redraws.
     */
    const updateSimulation = () => {
        // Update state from inputs
        cameraState.resolution = parseInt(document.getElementById('resolution').value);
        cameraState.sensorSize = parseFloat(document.getElementById('sensorSize').value);
        cameraState.hfov = parseInt(document.getElementById('hfov').value);
        cameraState.mountingHeight = parseFloat(document.getElementById('mountingHeight').value);

        // Validate and ensure min/max values are respected
        cameraState.sensorSize = Math.max(1, Math.min(10, cameraState.sensorSize));
        cameraState.mountingHeight = Math.max(1, Math.min(10, cameraState.mountingHeight));
        
        // Update HFOV display
        hfovValueSpan.textContent = cameraState.hfov;

        // Perform calculations
        calculateCoverage();
        const networkCapacity = calculateNetworkCapacity();

        // Update output fields
        focalLengthOutput.textContent = `${cameraState.focalLength} mm`;
        ppm10mOutput.textContent = `${cameraState.ppmAt10m} PPM`;
        networkOutput.textContent = `${networkCapacity.bandwidthMbps} Mbps / ${networkCapacity.storageGBPerDay} GB/Day`;

        // Redraw canvas
        drawSimulation();
    };

    // --- Event Listeners ---
    
    // Listen for changes on all form elements
    configForm.addEventListener('change', updateSimulation);
    configForm.addEventListener('input', (e) => {
        // Use 'input' for range slider for smooth updates
        if (e.target.id === 'hfov') {
            updateSimulation();
        }
    });
    
    // Handle responsive resizing
    window.addEventListener('resize', updateSimulation);

    // Initial run
    updateSimulation();
});
</script>
</body>
</html>
